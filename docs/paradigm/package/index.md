# 01背包
> $N$ 种物品，每种物品 $1$ 个，每个物品有重量和价值，有一个质量为V的背包，第 $i$ 件物品的体积为 $c[i]$，重量为 $m[i]$
> 问：背包放入物品后总价值最大是多少？

1. 暴力解法：每个物品只有两种状态（取or不取）：$O(2^n)$
2. 动态规划：

## 二维数组解法

### step 1
**`dp[i][j]`解释** : 任取 $[0, i]$ 编号的物品，放进容量为 $j$ 的背包中，得到的最大价值 (因此问题就转换为`dp[N-1][V]`)
> 假设编号从0开始，因此N-1就是最后一个物品的编号

### step 2
对于任意一个物体i，有**两种状态**：
1. 不放物品i: `dp[i][j] = dp[i-1][j]`
2. 放物品i: `dp[i][j] = dp[i-1][j-w[i]] + c[i]`
> 🌟 这里如果不懂，把他翻译为前面对`dp[i][j]`的解释就容易理解了

### step 3
因此得到了**动态规划方程**：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + c[i])`
$$ dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + c[i]) $$

### step 4
**初始化dp数组**：
对于 $dp[i][j]$ ，需要先知道 $dp[i-1][j]$ 和 $dp[i-1][j-w[i]]$ ，即需要知道前一行和前若干列的值，这里 $m[i] <= j$ 否则不放物品，因此需要初始化第一行和第一列
$$ dp[0][(?)] = ((?) >= m[0]) ? c[0] : 0 $$
$$ dp[(?)][0] = 0 $$
> 其他位置如何初始化：因为是直接赋值，所以不需要初始化

|  i\j   | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | ... |
| :----: | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| thing0 |     |     |     |     |     |     |     |     |     |     |     |
| thing1 |     |     |     |     |     |     |     |     |     |     |     |
| thing2 |     |     |     |     |     |     |     |     |     |     |     |
|  ...   |     |     |     |     |     |     |     |     |     |     |     |

### code

```java
int $01Package(int[] m, int[] c, int N, int V) {
  // init dp array
  int[][] dp = new int[N][V+1];
  // default value in dp is 0
  // so we don't need to init dp[?][0] 
  for (int i = 0; i < N; i++) {
    dp[i][0] = 0;
  }
  for (int j = 0; j <= V; j++) {
    dp[0][j] = (j >= m[0]) ? c[0] : 0;
  }
  // dp
  for (int i = 1; i < N; i++) {
    for (int j = 1; j <= V; j++) {
      if (j < m[i]) {
        dp[i][j] = dp[i-1][j];
      } else {
        dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-m[i]] + c[i]);
      }
    }
  }
  return dp[N-1][V];
}
```

> 由正上方和左上方推导出来，因此两层for循环的顺序可以调换
> 时间复杂度：$O(NV)$
> 物品体积满足：不能超过背包容量
> 物品价值满足：最大
> dp[i][j] = p
> i: 物品编号
> j: 背包容量
> p: 最大价值
> 选择item而不是必须全选

## 一维数组解法
观察上面二维数组解法的动态规划方程
$$ dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + c[i]) $$
> 由于每次只用到了上一行的值，因此可以用一维数组来代替二维数组
因此动态规划方程可以改写为：
$$ dp[j] = max(dp[j], dp[j-w[i]] + c[i]) $$

### code
> 代码优化：
> 1. 对于物品 $[1, i]$ ，如果 $j<m[i]$ ，则 $dp[j]$ 不会改变，因此可以直接跳过
> 2. 内层循环反向遍历保证了 $j < m[i]$ ，$j < m[i]$ 的所有 $dp[j]$ 不改变，也就是 $dp[i][j] = dp[i-1][j]$ ，第一维被省略，也就是 $dp[j] = dp[j]$ ，因此可以省略
> 3. dp只需要在循环里初始化，因此可以看到外层循环的初值为0，此时dp均为0，所以实际执行的是，`dp[j] = (j >= m[0]) ? c[0] : 0`;
```java
int $01Package(int[] m, int[] c, int N, int V) {
  // dp array
  int[] dp = new int[V+1];
  // i >= 0: dp
  for (int i = 0; i < N; i++) {
    for (int j = V; j >= m[i]; j--) {
      dp[j] = Math.max(dp[j], dp[j-m[i]] + c[i]);
    }
  }
  return dp[V];
}
```

# 完全背包
> $n$种物品，每种$m$个

# 多重背包
> $n$种物品，每种$m_i$不相同